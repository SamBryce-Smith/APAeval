"""Snakemake pipeline for Dapars2.
For help see: https://snakemake.readthedocs.io/en/stable/index.html.
"""

import pandas as pd

samples = pd.read_csv(os.path.abspath(
    config["samples"])).set_index("sample", drop=False)


#-------------------------------------------------------------------------------
localrules: finish

rule finish:
    """Rule that specifies the final output.
    """
    input:
        os.path.join(config["out_dir"], "[IDENTIFIER]_[METHOD].[OUTFORMAT]")


#-------------------------------------------------------------------------------
# Preprocessing: obtain suitable input formats

rule addChrToGtf:
    """This step adds 'chr' prefix to gtf file.
    """
    input:
        "gencode_2genes_noChr.vM18.annotation.gtf"
    output:
        "gencode_2genes_Chr.vM18.annotation.gtf"
    log:
        os.path.join(config["local_log"], "addChrToGtf.log")
    shell:
        "awk '{ if($1 !~ /^#/){print "chr"$0} else{print $0} }' {input} >{output}"

rule addChrToGff3:
    """This step adds 'chr' prefix to gtf file.
    """
    input:
        "gencode_2genes_noChr.vM18.annotation.gff3"
    output:
        "gencode_2genes_Chr.vM18.annotation.gff3"
    log:
        os.path.join(config["local_log"], "addChrToGff3.log")
    shell:
        "awk '{ if($1 !~ /^#/){print "chr"$0} else{print $0} }' {input} >{output}"

rule addChrToBed:
    """This step adds 'chr' prefix to bed files of samples.
    """
    input:
        "{sample}.MACESeq.mm10.bed"
    output:
        "{sample}_Chr.MACESeq.mm10.bed"
    log: 
        os.path.join(config["local_log"], "addChrToBed")
    shell:
        "awk '{ if($1 !~ /^#/){print "chr"$0} else{print $0} }' {input} >{output}"

rule addChrToBam_1:
    """This is the first step of adding 'chr' prefix to bam files of samples. This process adds 'chr' prefix to bam header.
    """
    input:
        bam=lambda wildcards:
            pd.Series(samples.loc[wildcards.sample, "bam"]).values
    output:
        "{sample}_Chr_Header.bam"
    log:
        os.path.join(config["local_log"], "addChrToBam_1")
    shell:
        "samtools view -H siControl_R1_2genes.bam | sed -e 's/SN:\([0-9XY]*\)/SN:chr\1/' -e 's/SN:MT/SN:chrM/' >{output}"

rule addChrToBam_2:
    """This is the second step of adding 'chr' prefix to bam files of samples. This process adds 'chr' prefix to bam body.
    """
    input:
        "{sample}.bam"
    output:
        "{sample}_Chr_Body.bam"
    log:
        os.path.join(config["local_log"], "addChrToBam_2")
    shell:
        "samtools view {input} | awk 'BEGIN {OFS="\t"} { print $1,$2,"chr"$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15 }' >>{output}"

rule addChrToBam_3:
    """This is the final step of adding 'chr' prefix to bam file. This process concatenate the header and the body of the previous bam files.
    """
    input:
        header="{sample}_Chr_Header.bam",
        body="{sample}_Chr_Body.bam"
    output:
        "{sample}_Chr.bam"
    log:
        os.path.join(config["local_log"], "addChrToBam_3")
    shell:
        "cat $(samtools view -H {input.header}) $(samtools view {input.body})"

rule sortBam:
    """This step sorts bam files with 'chr'.
    """
    input:
        "{sample}_Chr.bam"
    output:
        "{sample}_Chr_sorted.bam"
    log:
        os.path.join(config["local_log"], "sortBam")
    threads:
        4
    shell:
        "samtools sort -@ {threads} -o {output} {input}"

rule indexBam:
    """This step indexes sorted bam files.
    """
    input:
        "{sample}_Chr_sorted.bam"
    output:
        "{sample}_Chr_sorted.bam.bai"
    log:
        os.path.join(config["local_log"], "indexBam")
    threads:
        4
    shell:
        "samtools index -b -@ {threads} {input}"

rule generateBedgraph:
    """This step generates bedgraph files from sample bams.
    """
    input:
        "{sample}_Chr_sorted.bam"
    output:
        "{sample}_Chr.bedgraph"
    log:
        os.path.join(config["local_log"], "generateBedgraph")
    shell:
        "genomeCoverageBed -bg -ibam {input} >{output}"

rule generatePathReadcounts:
    """This step counts the aligned read of each sample and write  the abspaths and the numbers to a txt.
    """
    input:
        "{sample}_Chr_sorted.bam" 
    output:
        "pathReadcounts.txt"
    log:
        os.path.join(config["local_log"],"generatePathReadcounts")
    shell:
        "touch {output}
        echo "$(cd "$(dirname {input})" && pwd -P)/$(basename {input})"$'\t'$(samtools view -c -F 260 {input}) >>{output}"

rule getBed12_1:
    """This step generates genePred from gff3. This is the first step for generate 12 column bed file.
    """
    input:
        "gencode_2genes_Chr.vM18.annotation.gff3"
    output:
        "gencode_2genes_Chr.vM18.genePred"
    log:
        os.path.join(config["local_log"], "getBed12_1.log")
    shell:
        "./scripts/gff3ToGenePred {input} {output}"       

rule getBed12_2:
    """This step generates 12 column bed file from genePed. This is the second step for generate 12 column bed file
    """
    input:
        "gencode_2genes_Chr.vM18.genePred"
    output:
        "gencode_2genes_Chr.vM18.bed"
    log:
        os.path.join(config["local_log"], "getBed12_2.log")
    shell:
        "./scripts/genePredToBed {input} {output}"
        
rule extractGeneIdAndName:
    """This step extracts gene ID and gene symbol from gtf.
    """
    input:
        "gencode_2genes_Chr.vM18.annotation.gtf"
    output:
        "geneIdSymbol.txt"
    log:
        os.path.join(config["local_log"], "extractGeneIdAndName")
    shell:
        "python ./scripts/extractIdSymbol.py <{input} >{output}"

#-------------------------------------------------------------------------------
# Method-specific rules
rule getRegionAnnotation:
    """This step generate 3UTR region annotation.
    """
    input:
        urt="gencode_2genes_Chr.vM18.bed",
        symbol="geneIdSymbol.txt"
    output:
        "extracted_3UTR.bed"
    log:
        os.path.join(["local_log"], "getRegionAnnotation")
    conda:
        "./envs/dapars2.yml"
    shell:
        "python2 ./scripts/DaPars_Extract_Anno.py -b {input.utr} -s {input.symbol} -o {output}"

rule makeDapars2Config:
    """This step makes configure file for DaPars2.
    """
    input:
        utr="gencode_2genes_Chr.vM18.bed",
        seqDepth="pathReadcounts.txt",
        bedgraph=expand("{sample}_Chr.bedgraph", sample=sample)
    output:
        "Dapars2_configure_file"
    params:
        covThreshold="10"
    threads:
        4
    log:
        os.path.join(config["local_log"], "makeDapars2Config")
    run:
        sample_list=""
        for i in input.bedgraph:
            name=str(i)[:-9]
            sample_list=sample_list+name+","
        sample_list=sample_list.strip(",")
        with open({output}[0], "w") as f:
            print("# The following file is the result of generate_region_annotation", file=f)
            print("Annotated_3UTR="+str(input.utr), file=f)
            print("A comma-separated list of bedgraph files of all samples", file=f)
            print("Aligned_wig_files="+sample_list, file=f)
            print("Output_directory=DaPars2_results", file=f)
            print("Output_result_file=DaPars2_results", file=f)
            print("Coverage_threshold="+{params.covThreshold}, file=f)
            print("Num_Threads = "+{threads}, file=f)
            print("sequencing_depth_file="+{input.seqDepth})

rule mainDapars2:
    """This step runs DaPars2 on multiple samples and multiple chromosomes.
    """
    input:
        "Dapars2_configure_file"
    output:
        os,path.join(config["out_dir"], "{sample}", "DaPars2_result_chr1")
    log:
        os.path.join(["local_log"], "execute.mainDapars2.log")
    conda:
        os.path.join(config["envs"], "dapars2.yaml")
    shell:
        "python2 DaPars2_Multi_Sample_Multi_Chr.py Dapars2_configure_file"

#-------------------------------------------------------------------------------
# Postprocessing: obtain suitable output formats (for benchmarks)

rule postprocess_step_1:
    """A rule that does some postprocessing.

    Note: expand() with wildcard sample gathers all samples.

    """
    input:
        expand(os.path.join(config["out_dir"], "{sample}", "execute.out"),
            sample = samples.index)
    output:
        os.path.join(config["out_dir"], "[IDENTIFIER]_[METHOD].[OUTFORMAT]")
    log:
        os.path.join(config["local_log"], "postprocess_step_1.{sample}.log")
    shell:
        "(cat {input} {output}) &> {log}"


#-------------------------------------------------------------------------------
# How did it go?
#-------------------------------------------------------------------------------
onsuccess:
    print("Workflow finished, no error")

onerror:
    print("An error occurred, check log at %s." % {log})
